#include <stdio.h>
#include <stdlib.h>
#include "parser.h"
#include "front.h"


void error(int errorCode) {
    printf("Error encounter: The next lexeme was %s and the next token was %s \n" ,lexeme, tokenToString(nextToken));

    errorflag +=1;
    exit(1);

}


/**
 * This is the example Recursive-Descent Parser in pp. 181 - 185 in the 
 * textbook 
 *
 * Sebesta, R. W. (2012). Concepts of Programming Languages. 
 * Pearson, 10th edition.
 *
 *
 * */



/* condition
 * Parses the condition according to the BNF rule:
 * C ::= E < E | E > E | E == E | E != E | E <= E | E >= E
 */
void cond() {
    printf("Enter <cond>\n");

    /* Parse the left-hand side expression (E) */
    expr();

    /* Check for comparison operators */
    switch(nextToken){
        case LESSER_OP:
        case GREATER_OP:
        case EQUAL_OP:
        case NEQUAL_OP:
        case LEQUAL_OP:
        case GEQUAL_OP:
            lex();
            expr();
            break;
        default:
            error(1);
            printf("error in cond");
            break;
    }
    printf("Exit <cond>\n");
}


/* stmt
 * Parses strings in the language generated by the rule:
 * <stmt> -> <var> = <expr> | read(V) | write(V)|do {S} while(C) |<stmt>;<stmt>
 */
void stmt() {
    printf("Enter <stmt>\n");

    // Check for variable assignment
    if (nextToken == IDENT) {
        lex(); // Consume IDENT
        if (nextToken == ASSIGN_OP) {
            lex(); // Consume ASSIGN_OP
            expr(); // Parse expression
        } else {
            error(2);
            printf("Error in stmt: expected assignment operator\n");
        }
    }
        // Check for read operation
    else if (nextToken == KEY_READ) {
        lex(); // Consume READ
        if (nextToken == LEFT_PAREN) {
            lex(); // Consume LEFT_PAREN
            if (nextToken == IDENT) {
                lex(); // Consume IDENT
                if (nextToken == RIGHT_PAREN) {
                    lex(); // Consume RIGHT_PAREN
                } else {
                    error(2);
                }
            } else {
                error(2);
            }
        } else {
            error(2);
        }
    }
        // Check for write operation
    else if (nextToken == KEY_WRITE) {
        lex(); // Consume WRITE
        if (nextToken == LEFT_PAREN) {
            lex(); // Consume LEFT_PAREN
            if (nextToken == IDENT) {
                lex(); // Consume IDENT
                if (nextToken == RIGHT_PAREN) {
                    lex(); // Consume RIGHT_PAREN
                } else {
                    error(2);
                }
            } else {
                error(2);
            }
        } else {
            error(2);
        }
    }
        // Check for do-while loop
    else if (nextToken == KEY_DO) {
        lex(); // Consume DO
        if (nextToken == LEFT_CBRACE) {
            lex(); // Consume LEFT_CBRACE
            stmt(); // Parse statement inside do-while block
            if (nextToken == RIGHT_CBRACE) {
                lex(); // Consume RIGHT_CBRACE
                if (nextToken == KEY_WHILE) {
                    lex(); // Consume WHILE
                    if (nextToken == LEFT_PAREN) {
                        lex(); // Consume LEFT_PAREN
                        cond(); // Parse condition
                        if (nextToken == RIGHT_PAREN) {
                            lex(); // Consume RIGHT_PAREN
                        } else {
                            error(2);
                        }
                    } else {
                        error(2);
                    }
                } else {
                    error(2);
                }
            } else {
                error(2);
            }
        } else {
            error(2);
        }
    }
        // If none of the above, it's an error
    else {
        error(2);
    }if (nextToken == SEMICOLON) {
        lex(); // Consume SEMICOLON
        stmt(); // Parse next statement
    }

    printf("Exit <stmt>\n");
}
/* expr
 * Parses strings in the language generated by the rule:
 * <expr> -> <term> {(+ | -) <term>}
 */
void expr() 
{
    printf("Enter <expr>\n");

    /* Parse the first term */
    term();

    /* As long as the next token is + or -, get
    the next token and parse the next term */
    while (nextToken == ADD_OP || nextToken == SUB_OP) {
        lex();
        term();
    }

    printf("Exit <expr>\n");
} /* End of function expr */

/* term
 * Parses strings in the language generated by the rule:
 * <term> -> <factor> {(* | /) <factor>)
 */
void term() 
{
    printf("Enter <term>\n");
    /* Parse the first factor */
    factor();
    /* As long as the next token is * or /, get the
    next token and parse the next factor */
    while (nextToken == MULT_OP || nextToken == DIV_OP) {
            lex();
            factor();
    }
    printf("Exit <term>\n");
} /* End of function term */

void opp(){
    if (nextToken == INC_OP || nextToken == DEC_OP){
        lex();

    }
}

/* factor
 * Parses strings in the language generated by the rule:
 * <factor> -> (<expr>) | <opp> | <var> | <num>
 * */
void factor(){
    printf("Enter <factor>\n");

    //parse the first term
    if(nextToken == LEFT_PAREN){
        lex(); // eat left paren
        expr();

        if (nextToken == RIGHT_PAREN){
            lex(); // eat right paren
        } else {
            error(5);
        }
    }else if (nextToken == IDENT) {
        lex(); //eat var
        opp();

    } else if (nextToken == INT_LIT) {
        lex(); // eat number

    }
    else {
        error(5);
    }
    
     /* End of else */
    printf("Exit <factor>\n");;
} /* End of function factor */

